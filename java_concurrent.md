## volatile
 
 volatile在java内存模型中是用来保证变量的可见性，这个关键字的语义在JSR133标准中得到了增强。内存模型假定每个线程都有自己的私有的缓冲区，线程读写变量，首先是在私有缓冲区里面进行读写，然后异步的刷入主存，刷入主存的时机不是线程自己来控制，而是依赖于操作系统。当一个线程A对变量x进行更改时，实际上是读取主存中的变量x在线程A的缓冲区的副本xa，然后对xa进行修改，并不会保证立即把对xa的更新刷入到主存中来更新x。如果同时有一个线程B读取变量x，它可能读取到的是变量x在线程B的缓冲区中的副本xb，或者是主存中未更改的x。也就是说，线程A对变量x的更改对于线程B而言是不可见的。
 这样的模型不是无根之木，无源之水，设计这样的模型，很大程度上是计算机的存储器层次架构就是这种类似的模型，jvm内存模型只是高层次上的操作系统的内存模型，比如：
 ![core i7 cache](./img/i7cache.png)

 在CPU上的存储器层次结构中，每个核都拥有自己的L1，L2 cache，越低级别的cache容量越小，速度越高.比如从L1中读取一个字需要几个时钟周期，L2中是数十个时钟周期，L3是约50个时钟周期，从主存中获取约200个时钟周期。java内存模型的线程的私有缓冲区是基于这样一种存储器结构层次设计的，假定人们能够编写有良好局部性的代码，使得对变量的读写一般来说能够被多次使用，读写都是基于低层次的缓存区。更改完变量后，并不会进行直写(write-through)，即把更新写到上一级的缓存中，这种方式每次更新都会显著的增加内存总线的流量。一般而言，cpu更会选择写回(write-back)，这种方式是当低层次缓存更改后，不直接相应的去更改高级缓存，而是等到必要时，比如低层次缓存容量满了，会依据相应的算法如LRU把低层次缓存中整行的数据驱逐并刷入高级缓存中，这也就是jvm内存模型中不可见性在物理机中的来源。volatile提供的语义，是要求线程对volatile变量的读写，都要基于主存，即每次读，都要从主存中进行加载，每次写，都要写回到主存。这里只是简单的描述，精确的描述要基于happens-before规则。

 jvm内存模型中不可见性除了缓存系统外，还有的就是指令重排。出于性能的考量，编译器会对用户编写的代码在不影响语义的情况下，会进行重排序，CPU会对不存在数据依赖性的指令进行重排序，CPU除了缓存数据，也会缓存指令，使得指令的加载和执行也可能会进行重排序。用户编写的代码中的顺序带来的可见性，因为指令被重排使得效果不可见。volatile在这里的作用，就是禁止指令的重排序。

 volatile的语义是保证变量的可见性，具体的做法就是内存读写基于主存和禁止指令重排序，实现这些功能是基于CPU提供的内存屏障，内存屏障比如StoreLoad Barriers，会确保更改数据对其它核是可见的，使用屏障时，对要求之前的内存访问指令都已完成，然后执行屏障，再执行后续指令，即禁止重排序。当然，使用这样的屏障开销是相对昂贵的，把L1 cache的缓存都刷入到内存中，需要200个时钟周期。
