
# How to make raft

## 共识

在分布式系统中，参与节点对某一个提案达成一致的过程，称之为共识。如何构建一个算法，能够稳定的构建共识，这是一个分布式领域的经典问题。

比如我们的系统是一个Key-Value类型的存储服务，当我们把一个KV值存储到服务中，系统中不止一个节点接受了这个值。多备份的好处是提高了可用性，出错的概率比单节点要高，多备份也相应增加了请求处理能力和IO带宽，带来的麻烦就是怎么去做备份。多节点系统要不要接受这个值，以何种方式来接受这个值，系统外的客户端如何确认系统已经接受了这个值，这就是个共识问题。

## 背景

### 通信

我们假定系统中每个节点只能通过网络通信交流，TCP协议是个动态分配协议，能最大化的利用带宽。网络请求可能在内核缓冲区排队，可能在网卡端口排队，可能在接受方的网卡端口排队，可能在接受方的内核缓冲区排队等等，导致了网络请求时间没有上确界，有以下几个结果：

1. 节点只能通过目标节点的回复才能确认消息已经到达。

2. 当一个请求没有回复时，节点不能确定这个请求是没发出去，还是发出去没有接收，还是接收了没有处理，还是处理了没有返回，还是返回了没有收到。

3. 当一个节点没有响应，其它节点不能确定这个节点到底是没有存活，还是网络连接问题。

网络通信的特质就是不可靠的，共识协议就是在这种不可靠的环境下构建一个可靠的算法。

### 时间

在分布式系统中，时间也不是可靠的。每个节点由于自身的硬件、环境，硬件所反映的时间都会有些许误差，很多机房内的机器都会持续的以特殊的时间服务器来分发时间让其它机器进行同步，谷歌的机房就是用原子钟作为标准时间机的。

每个服务器都存在时差，这也导致我们在碰到争议请求时，很难按照时间去判断先后，如何处理时间，也是一个麻烦的问题。

### 主从架构

一个最简单的共识算法实现方式，就是主从架构。系统中某一个节点作为主节点，其它节点作为从节点，主节点接受请求，并把请求分发给从节点，从节点接受从主节点分发的请求。节点间达成共识的算法核心就是只有主节点做出决定，从节点做出跟随。

### 复制状态机

纯函数是一类这样的函数，它的输出仅取决于输入，在函数式编程中，纯函数是核心，它让人不用考虑额外的状态，把编程的关注点仅仅集中你所要关注的单个函数上。考虑到一个初始状态，然后经过一系列纯函数的操作，这一系列纯函数有一个固定的顺序，每个函数的输入是前继函数的输出，输出是后继函数的输入。给定某个特定的初始状态和这样的一系列纯函数操作，无论重复操作多少次，应该得到一样的操作结果。

JavaScript里面有个Redux框架，应用了这一套理念，初始状态就是Redux里面的Store，纯函数就是Action和Reducer，Redux可以重复复现结果来进行Debugger，靠的就是纯函数的“纯”，输出仅取决于输入，我们使用日志插件记录下每一个Action，从一个固定的Store出发，就能得到Store的每一个历史状态。

放到分布式领域，复制状态机就是类似这样的东西，一般用在日志上面。比如我们把请求封装成一个日志项，纯函数操作就是把日志项简单的放到原有日志的后面。一个日志，用固定的顺序添加了一系列日志项，最后得到一个日志。重复这样的操作，这个最终日志应该都是一样的。比如Redis的AOF(Append Operations File)，就是记录操作的日志，当然涉及到时间、随机函数的操作项会预先处理成所得值，这样的操作日志可以用于恢复或者备份。

## 算法

从前面所述的主从架构和复制状态机，我们已经能够构建一个简单的共识算法了。算法中，有一个主节点，其余都是备份节点，只有主节点来做出决定，从节点跟随主节点的决定。外界的一个提案，封装成一个日志项，主节点做出决定的方式，就是把这个日志项添加到自己的日志上。初始化状态下，每个节点的日志都是相同的，可以是一个空日志。从节点如果收到客户端的提案请求，要引导客户端把请求发送到主节点上，不能自行接受。主节点负责把提案日志按照自己的顺序分发给从节点，从节点只能按照主节点的日志顺序来接受到自己的日志上面。当这个提案日志在所有节点的相同位置的日志项上面，可以说这个提案达成共识了。

现在，我们的问题就是如何选取这个主节点。

一种简单的方式就是初始化的时候就决定好一个主节点，大部分情况下这个主节点能够好好工作，万一主节点出故障了，没有人想在半夜里被叫起来修改配置重启服务器吧？还是得想个办法动态选取主节点。



