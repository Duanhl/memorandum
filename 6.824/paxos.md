# Paxos

## Algorithm

### Problem

* 提案：一个请求，可以是任意值，比如要求参与节点修改某个变量值为特定值的命令

* 节点：参与选举、学习的独立进程

假设一个进程集合中任何一个进程能提出提案，共识算法就是从提案集中选出一个特定的值的算法。如果一个值被选中了，进程需要学习这个值。“学习”这个过程就是进程知道该选中值并把该选中值作为最终不可改变的值保存到自身的过程。

从问题的陈述，得到下列安全条件：

* 只能是进程提案集中的值可能被选择
* 只能有一个值被选中
* 当一个值被选中了，进程才能学习它

算法目标是在不预定活性条件下，保证进程可以从提案集中最终一定能够选举出某个值，且任何节点最终能够学习到这个值。

我们可以把进程集中的进程分成三种角色，角色在服务节点实体上可以是重叠的：

1. proposers，发起提案的角色
2. acceptors，接受提案的角色
3. learners，学习选中值的角色

我们选择一个异步通信、无拜占庭错误的模型：

1. 进程可能挂掉，可能会重启。很明显，进程需要采用某些持久化技术来保证重启过程中部分信息不会丢失。

2. 进程间通信是异步的，消息可能通过任意长时间才能送达，消息可能重复，可能丢失，但是消息不会出错。

### 选举值

一个Proposer发送一个提案值给Acceptors，一个Acceptor可能接受这个值也可能没接受，当大多数Acceptor接受这个值，称这个值被选中了，“大多数”这个条件意味着只有一个值能够被选中。

由于异步消息的效率问题，可以提出一个这样的条件：

> **P1. Acceptor必须接受第一个收到的提案**

P1会带来一个活性问题，如果有多个提案需要被选择，投票可能分散，一个提案是大多数。即使只有两个提案，可能某个节点断开连接，导致两个提案也无法决出大多数。为了解决这个问题，一个Acceptor可能需要接受多个提案。为了区分提案，我们给不同提案给一个序列号，不同的提案具有不一样的序列号，序列号应该是惟一递增的，如此，提案的结构就成了下面的：

```js
{
    pn: proporsal num
    v:  value
}
```

当某个提案被大多数Accptor接受，这个提案里面的值称之为被选中了，该提案也称之为被选中了。当一个Accptor接受多个提案时，提案里面的值应该是一样的，这样才能保证被选中的提案有同样的值。

把某个pn为n，value为v的提案记做(n, v)，引入条件P2

> **P2. 如果提案(n, v)被选中了，提案(m, ?)也被选中，且 m > n，该提案的值也必须是v**

由于序列号是全序的，从P2条件出发，保证了只有一个值能被选中

对P2条件进行加强：

> **P2a. 如果提案(n, v)被选中了，被任意Acceptor所接受的提案(m, ?)，假设 m > n，该提案的值必须是v**

只要是被选中的提案，肯定至少被一个Acceptor所接受，满足了P2a，实际上就满足了P2。

由P1和P2a，假设存在这样一个Acceptor a 和一个Proposer p，两个节点之前睡眠了，一直没有参与选举过程，选举在没有这两个节点也满足大多数的条件下达成了共识提案。两个节点突然醒来了，p提出一个高序异值的提案，由P1条件，a接受了p的提案，这就破坏了条件P2a，P1和P2a发生了冲突。为了解决这种状况，可选方案就是a需要能够拒绝提案，比如在这种情景中，a如果要拒绝提案的话，如果策略基于提案本身的信息的话，a首先得获取多个提案才能知道拒绝哪个提案，在异步通信系统中，这是个很难实现的需求。换一个思路，从Proposer入手，如果p的提案的值和共识提案的值一样的话，a去接受p这个提案，也是符合P2a的。

> **P2b. 如果提案(n, v)被选中了，被任何Proposer提出来的提案(m, ?)，假设 m > n，该提案的值都必须是v**

由于Acceptor接受的提案必须是某个Proposer提出来的提案，P2b很明显包含了P2a。

假设某个提案(m, v)的提案被选中了，对于任意n > m，被提出来的提案(n, ?)的值由P2b可知都应该是v。

必然存在某个包含大多数Accptor的集合C，C中任意一个Accptor都接受了提案(m, v)，只有是这样，提案(m, v)才能视为被选中的。

> 集合C中的每个Acceptor都接受过提案(x, ?), 其中 m <= x <= n - 1，对于任意一个被任何C中Acceptor接受过的这样的提案(x, ?)，它的值都是v。

上述推论相对于P2a，把全集弱化成了多数集。

假设任意包含多数Accptor的集合S，由于C也是多数Accptor的集合，S和C必定存在至少一个公共Accptor，我们可以得到条件：

> **P2c. 对于任意提出来的提案(n, v)，存在一个包含多数Accptor的集合S，(1)要么S中不存在Accptor接受过pn < n的提案，(2)要么S中Accptor所接受过的pn < n的提案，其中pn最大的提案，它的值是v**

可以证明P2c是P2b的不变式。假如提案(m, v)被选中，用反证法，如果提案(m+, w)被提出来了，其中m+ 是 m的后继元素, w != v，由P2c，存在一个多数Acceptor的集合S，要么S中不存在Acceptor接受过pn < n的提案，由于S和合法集C有公共元素，这条不成立。要么S中Acceptor接受过所有pn < n的提案，其中pn值最大的提案，由于m+是m的后继元素，实际上就是这个公共元素所接受过的选中提案(m, v)，所以w应该就是v。

继续进行归纳，如果pn 在 m+...n- 的提案的值都是v，其中n-是n的前置元素，继续用反证法，提案(n, ?)的值假设为w，其中w != v，由P2c，多数集S和合法集C存在公共元素，P2c(1)条件不成立，考虑P2c(2)，(n, w)的值来源于某个提案(x, w)，其中x < n，我们知道m...n-的提案值都是v，那么x就应该比m还小，但是由于公共元素的存在，多数集中所接受过的最大pn值提案，必然大于或等于m，构成矛盾。从P2c和合法集合C的性质，得到了P2b。

P2c这是一个可以实现的模型，如果想要选中一个值，要不就提出一个没有提出过的值，在共识系统中可以是客户端发送的命令，要不就选择一个多数集，询问它们当前持有的最大pn的提案，把返回提案之中最大pn的提案拿出来，提高pn，当成一个新的提案，这样持续做下去，选中提案实际上早就浮现了。

同样的，可能也有另外的Proposer也再对另外一个多数Acceptor集做这样的操作，这两个多数集有共同元素。为了避免冲突，Proposer可以选择发出一个pn = n的Promise，要求一个多数Acceptor集S中的Acceptor承诺不要再接受比pn < n的提案，并且获取这些Acceptor的曾经接受过pn < n中pn最大的提案，因为S中pn < n且pn值最大的提案必定出自这些提案。所以这个算法的细节归结成：

1. 某个Proposer选择一个新的pn值**n**并且发送这个请求到多数Accptor集S中任何一个Acceptor，要求以下回复：
    1. 承诺永远不会再接受比**n**更小的提案
    2. 曾经接受过的比**n**以下最大pn提案

这个阶段的请求称之为预请求

2. 一旦这个Proposer接受到多数Acceptor的响应，可以提出提案，这个提案为(n, v)，其中**v**是收到响应中最大pn值的提案的v值，如果响应中没有提案，这个Proposer可以选择任意一个提案值。

这个阶段的请求称之为提案，提案请求对象的Acceptors和预请求的Acceptor保持一致。

对于接受方，如果接受了预请求，自然要接受提案请求，还可以扩张一下，只要它没有拒绝过预请求，就可以接受提案请求：

> **P1a. 某个Acceptor可以接受一个pn = `n`的提案，只要它没有响应过一个pn > `n`的预请求**

显然P1a包含在P1中。

现在这里有一个完整的算法了，除了一个假设，我们有一个能够生成全序提案序列号的算法，比如用Proposer的Id和单节点生成的数字ID组合得到。然后还这里可以做一些优化。

如果一个Accptor接受过pn = n的预请求，它就不应该接受任何pn < n的预请求，同样的，也不应该接受过一个已经接受过的提案的预请求，Acceptor可以把这些请求都忽略掉。Acceptor也无须保存所有历史提案，只需要保存接受过的最大提案。

把Proposer和Acceptor的行为合并，可以把算法详细操作分为以下两个阶段：

1.  + 某个Proposer选择一个pn值`n`，然后发送一个pn = n的预请求给多数Acceptor

    + 如果一个Acceptor曾经响应过的预请求,都满足pn < n，这个Acceptor就要响应该Proposer不会再接受任何pn < n的预请求，如果它曾经接受过提案请求，响应里还需要有历史接受过的最大提案。

2.  + 如果Proposer收到了多数的Acceptor对于该预请求的响应，需要发送一个提案请求(n, v)给这些Acceptor，其中n是预请求的pn，v是响应中pn值最大的提案的值，如果响应中没有任何提案，Proposer可以选择任意值作为提案值。

    + 如果一个Acceptor接到一个提案请求(n, v)，只要它没有响应过任何pn > n的的预请求，就必须接受这个请求。

作为一个优化，如果Acceptor接受过比发过来的预请求还要大的预请求，可以响应自己的这个预请求告诉对方放弃这次提案。

### 学习值

最简单的学习方式是每个Acceptor在接受请求时就将自己的接受情况发给所有的所有的Learner，每个Learner自己分别统计请求情况，很明显这种方式请求数量太过庞大。可以选择某个特殊的Learner，Acceptor把请求发给他，这个Learner再转发给其它Learner，这个转发模式减少了请求次数，但是相应的带来可靠性的问题，这个Learner就是链条中的薄弱节点。

所以，可以折中的，选择一个Learner集来接受Acceptor的请求情况并转发给其它的Learner，增加的可靠性相应的也增加了网络请求的复杂程度。

由于Acceptor可能在接受过程后就挂掉，来不及把情况发给Learner，所以Learner应该主动发请求询问Acceptor，但是请求也可能得不到响应。此时，Learner作为一个Acceptor的话，可以上面的选举过程一样，发送一个试探性的提案来获取当前最新的选举值。

### 优化

考虑这样一种场景，假设有两个Proposer，记为p，q，首先p提出一个pn = n1的预请求，之后q提出pn = n2的预请求，n2 > n1，p首先得到了响应，正要执行二阶段时，q的预请求此时覆盖了p的预请求。p继续提出一个pn = n3的预请求，n3 > n2，当q要执行二阶段时，p继续覆盖掉q的预请求。如此反复，导致始终不能达成共识。

实际上，Paxos算法无法彻底解决活性问题，其实，由FLP定理，一个异步系统，不可能有在任何情况下都能够在有限步骤下达成共识的算法。

为了缓解这种状况，可以选择随机时间的算法，Proposer在被拒绝后等待随机时间后才能提出新的提案，避免这种活锁情况。更好的解决方案是选择一个特定的Proposer，由它负责提出Proporsal，只要这个Proposer能够和大多数Acceptor有网络连接，就能达成共识，这样的话，这个Proposer相当于充当了领导人的角色。如果网络不好或者其它故障，导致有多个Proposer宣称自己要做这个角色，就退化到最传统的Paxos算法。

## 实现状态机

首先，先实现一个决定性状态机，把选择的值封装成一个决定性的指令，类似于编程里面的纯函数，对于决定性状态机而言，假如每个节点初始状态是一样的，按照固定的顺序来执行一系列的决定性的操作序列，最后得到的结果，也应该是一样的。

每一轮Paxos操作，最后决出的结果作为这样一条指令。
